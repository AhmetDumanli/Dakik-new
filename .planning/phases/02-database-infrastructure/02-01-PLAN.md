---
phase: 02-database-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - docker/postgres/init/01-init-databases.sh
  - docker/postgres/init/02-seed-user-db.sql
  - docker/postgres/init/03-seed-event-db.sql
  - docker/postgres/init/04-seed-appointment-db.sql
  - docker/docker-compose.postgres.yml
autonomous: true

must_haves:
  truths:
    - "PostgreSQL container creates dakik_user, dakik_event, dakik_appointment databases on first startup"
    - "Seed data populates all 3 databases with test rows"
    - "Database data persists across container stop/start cycles"
    - "Databases are accessible at localhost:5432 with postgres/postgres credentials"
  artifacts:
    - path: "docker/postgres/init/01-init-databases.sh"
      provides: "Multi-database creation script"
      contains: "create_user_and_database"
    - path: "docker/postgres/init/02-seed-user-db.sql"
      provides: "User seed data"
      contains: "INSERT INTO"
    - path: "docker/postgres/init/03-seed-event-db.sql"
      provides: "Event seed data"
      contains: "INSERT INTO"
    - path: "docker/postgres/init/04-seed-appointment-db.sql"
      provides: "Appointment seed data"
      contains: "INSERT INTO"
    - path: "docker/docker-compose.postgres.yml"
      provides: "Standalone PostgreSQL service for testing"
      contains: "postgres:17"
  key_links:
    - from: "docker/docker-compose.postgres.yml"
      to: "docker/postgres/init/"
      via: "volume mount to /docker-entrypoint-initdb.d"
      pattern: "docker-entrypoint-initdb.d"
    - from: "docker/docker-compose.postgres.yml"
      to: "postgres-data volume"
      via: "named volume for persistence"
      pattern: "postgres-data:/var/lib/postgresql/data"
---

<objective>
Create PostgreSQL Docker infrastructure with automatic multi-database creation, seed data, and persistent storage.

Purpose: Enable local development with pre-populated databases that all 3 services (user, event, appointment) can connect to.
Output: Init scripts, seed data SQL files, and a standalone docker-compose file for testing PostgreSQL independently.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-database-infrastructure/02-RESEARCH.md

Source entities (for seed data column references):
@user-service/src/main/java/com/example/user_service/Entity/User.java
@event-service/src/main/java/com/example/event_service/Entity/Event.java
@appointment-service/src/main/java/com/example/appointment_service/Entity/Appointment.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PostgreSQL init script and docker-compose file</name>
  <files>
    docker/postgres/init/01-init-databases.sh
    docker/docker-compose.postgres.yml
  </files>
  <action>
Create `docker/postgres/init/01-init-databases.sh` — a shell script that creates multiple databases from the `POSTGRES_MULTIPLE_DATABASES` environment variable. Use the established pattern from the research:

```bash
#!/bin/bash
set -e
set -u

function create_user_and_database() {
    local database=$1
    echo "Creating database '$database'"
    psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" <<-EOSQL
        CREATE DATABASE $database;
        GRANT ALL PRIVILEGES ON DATABASE $database TO $POSTGRES_USER;
EOSQL
}

if [ -n "$POSTGRES_MULTIPLE_DATABASES" ]; then
    echo "Multiple database creation requested: $POSTGRES_MULTIPLE_DATABASES"
    for db in $(echo $POSTGRES_MULTIPLE_DATABASES | tr ',' ' '); do
        create_user_and_database $db
    done
    echo "Multiple databases created"
fi
```

IMPORTANT: The script must have Unix line endings (LF, not CRLF) since it runs inside a Linux container. Use `git config core.autocrlf` awareness or add a .gitattributes entry.

Create `docker/docker-compose.postgres.yml` — standalone PostgreSQL service for testing Phase 2 independently (Phase 3 will create the full stack compose file):

```yaml
services:
  postgres:
    image: postgres:17
    container_name: dakik-postgres
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: postgres
      POSTGRES_MULTIPLE_DATABASES: dakik_user,dakik_event,dakik_appointment
    volumes:
      - postgres-data:/var/lib/postgresql/data
      - ./postgres/init:/docker-entrypoint-initdb.d
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres -d dakik_user"]
      interval: 10s
      timeout: 10s
      retries: 5
      start_period: 30s

volumes:
  postgres-data:
    driver: local
```

Note the volume path is `./postgres/init` (relative to docker-compose file location in `docker/`).

Also create or update `.gitattributes` at the project root to ensure shell scripts keep LF line endings:
```
docker/postgres/init/*.sh text eol=lf
```
  </action>
  <verify>
Run: `docker compose -f docker/docker-compose.postgres.yml up -d` from the project root (C:\Users\PC\Desktop\Dakik).
Wait for healthy: `docker compose -f docker/docker-compose.postgres.yml ps` shows "healthy".
Verify databases: `docker exec dakik-postgres psql -U postgres -c "\l"` — output must list dakik_user, dakik_event, dakik_appointment.
  </verify>
  <done>PostgreSQL container starts, creates 3 databases automatically, and reports healthy.</done>
</task>

<task type="auto">
  <name>Task 2: Create seed data SQL scripts for all 3 databases</name>
  <files>
    docker/postgres/init/02-seed-user-db.sql
    docker/postgres/init/03-seed-event-db.sql
    docker/postgres/init/04-seed-appointment-db.sql
  </files>
  <action>
Since Hibernate `ddl-auto=update` creates the tables when services connect, seed data scripts must create tables explicitly because at init time no service has connected yet. The init scripts run BEFORE any service starts.

IMPORTANT: Seed scripts run during PostgreSQL initialization (before any Spring Boot service connects). Hibernate has NOT created tables yet. Therefore, each seed script MUST create the tables first, then insert data.

Create `docker/postgres/init/02-seed-user-db.sql`:
```sql
\c dakik_user;

CREATE TABLE IF NOT EXISTS users (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) NOT NULL UNIQUE,
    password VARCHAR(255) NOT NULL,
    created_at TIMESTAMP
);

INSERT INTO users (name, email, password, created_at) VALUES
    ('Test User', 'test@example.com', 'password123', NOW()),
    ('Demo User', 'demo@example.com', 'password123', NOW()),
    ('Admin User', 'admin@example.com', 'password123', NOW());
```

Create `docker/postgres/init/03-seed-event-db.sql`:
```sql
\c dakik_event;

CREATE TABLE IF NOT EXISTS events (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT,
    start_time TIMESTAMP,
    end_time TIMESTAMP,
    available BOOLEAN DEFAULT true,
    locked BOOLEAN DEFAULT false
);

INSERT INTO events (user_id, start_time, end_time, available, locked) VALUES
    (1, NOW() + INTERVAL '1 day', NOW() + INTERVAL '1 day 1 hour', true, false),
    (1, NOW() + INTERVAL '2 days', NOW() + INTERVAL '2 days 1 hour', true, false),
    (2, NOW() + INTERVAL '1 day', NOW() + INTERVAL '1 day 30 minutes', true, false),
    (2, NOW() + INTERVAL '3 days', NOW() + INTERVAL '3 days 2 hours', false, false);
```

Create `docker/postgres/init/04-seed-appointment-db.sql`:
```sql
\c dakik_appointment;

CREATE TABLE IF NOT EXISTS appointment (
    id BIGSERIAL PRIMARY KEY,
    event_id BIGINT,
    booked_by BIGINT,
    created_at TIMESTAMP,
    status VARCHAR(20)
);

INSERT INTO appointment (event_id, booked_by, created_at, status) VALUES
    (4, 3, NOW(), 'BOOKED');
```

Column names and types MUST match the JPA entity field mappings exactly (Hibernate default: camelCase -> snake_case). Cross-reference:
- User: id, name, email, password, created_at (table: users)
- Event: id, user_id, start_time, end_time, available, locked (table: events)
- Appointment: id, event_id, booked_by, created_at, status (table: appointment — no @Table annotation so defaults to class name lowercase)

The seed data should be referentially consistent across databases:
- Users 1, 2, 3 exist in dakik_user
- Events reference user_id 1 and 2
- Appointment references event_id 4 (the unavailable event) and booked_by user 3
  </action>
  <verify>
Stop and remove volume: `docker compose -f docker/docker-compose.postgres.yml down -v`
Start fresh: `docker compose -f docker/docker-compose.postgres.yml up -d`
Wait healthy, then verify seed data:
- `docker exec dakik-postgres psql -U postgres -d dakik_user -c "SELECT count(*) FROM users;"` — returns 3
- `docker exec dakik-postgres psql -U postgres -d dakik_event -c "SELECT count(*) FROM events;"` — returns 4
- `docker exec dakik-postgres psql -U postgres -d dakik_appointment -c "SELECT count(*) FROM appointment;"` — returns 1

Test persistence: `docker compose -f docker/docker-compose.postgres.yml stop` then `docker compose -f docker/docker-compose.postgres.yml start`, re-run counts — same results.
  </verify>
  <done>All 3 databases contain seed data. Data persists across container stop/start. Counts: 3 users, 4 events, 1 appointment.</done>
</task>

</tasks>

<verification>
1. `docker compose -f docker/docker-compose.postgres.yml ps` shows postgres healthy
2. `docker exec dakik-postgres psql -U postgres -c "\l"` lists all 3 databases
3. Seed data counts verified in each database
4. Stop/start cycle preserves data (do NOT use `down -v` which removes volumes)
5. `down -v` then `up -d` re-creates everything from scratch (clean reset works)
</verification>

<success_criteria>
- PostgreSQL container auto-creates dakik_user, dakik_event, dakik_appointment on first startup
- Seed data populates all 3 databases with realistic test data
- Data persists across stop/start cycles
- Volume removal + restart triggers fresh initialization
- All files use correct line endings for Linux container execution
</success_criteria>

<output>
After completion, create `.planning/phases/02-database-infrastructure/02-01-SUMMARY.md`
</output>
