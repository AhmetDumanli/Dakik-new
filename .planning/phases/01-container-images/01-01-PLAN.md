---
phase: 01-container-images
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - eureka-server/Dockerfile
  - eureka-server/.dockerignore
  - api-gateway/Dockerfile
  - api-gateway/.dockerignore
  - user-service/Dockerfile
  - user-service/.dockerignore
  - event-service/Dockerfile
  - event-service/.dockerignore
  - appointment-service/Dockerfile
  - appointment-service/.dockerignore
autonomous: true

must_haves:
  truths:
    - "Each Java service builds into a Docker image without errors"
    - "Docker images use multi-stage builds (builder + runtime stages)"
    - "Docker images exclude build artifacts via .dockerignore"
    - "Final images are optimized (under 300MB per service)"
    - "Images use distroless base for security"
  artifacts:
    - path: "eureka-server/Dockerfile"
      provides: "Multi-stage Docker build for Eureka Server"
      contains: "FROM eclipse-temurin:17-jdk AS builder"
    - path: "eureka-server/.dockerignore"
      provides: "Build context exclusions"
      contains: "target/"
    - path: "api-gateway/Dockerfile"
      provides: "Multi-stage Docker build for API Gateway"
      contains: "FROM eclipse-temurin:17-jdk AS builder"
    - path: "api-gateway/.dockerignore"
      provides: "Build context exclusions"
      contains: "target/"
    - path: "user-service/Dockerfile"
      provides: "Multi-stage Docker build for User Service"
      contains: "FROM eclipse-temurin:17-jdk AS builder"
    - path: "user-service/.dockerignore"
      provides: "Build context exclusions"
      contains: "target/"
    - path: "event-service/Dockerfile"
      provides: "Multi-stage Docker build for Event Service"
      contains: "FROM eclipse-temurin:17-jdk AS builder"
    - path: "event-service/.dockerignore"
      provides: "Build context exclusions"
      contains: "target/"
    - path: "appointment-service/Dockerfile"
      provides: "Multi-stage Docker build for Appointment Service"
      contains: "FROM eclipse-temurin:17-jdk AS builder"
    - path: "appointment-service/.dockerignore"
      provides: "Build context exclusions"
      contains: "target/"
  key_links:
    - from: "eureka-server/Dockerfile"
      to: "eclipse-temurin:17-jdk"
      via: "FROM statement in builder stage"
      pattern: "FROM eclipse-temurin:17-jdk AS builder"
    - from: "eureka-server/Dockerfile"
      to: "gcr.io/distroless/java17-debian12"
      via: "FROM statement in runtime stage"
      pattern: "FROM gcr.io/distroless/java17-debian12"
---

<objective>
Create optimized Docker images for all 5 Java Spring Boot microservices using multi-stage builds with Spring Boot layered jars and distroless runtime images.

Purpose: Enable containerization of all backend services with production-ready security and size optimization. This is the foundation for Phase 2 (database infrastructure) and Phase 3 (orchestration).

Output: Each of the 5 Java services will have a Dockerfile and .dockerignore, allowing them to be built as standalone Docker images with ~50-70% size reduction compared to single-stage builds.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-container-images/01-RESEARCH.md

Services to containerize:
- eureka-server (port 8761) - Service discovery
- api-gateway (port 8080) - API Gateway
- user-service (port 8081) - User CRUD
- event-service (port 8082) - Event CRUD + locking
- appointment-service (port 8083) - Appointment booking

All services:
- Spring Boot 3.3.5-4.0.1
- Java 17
- Maven build (pom.xml)
- Hibernate with ddl-auto (no Flyway/Liquibase)
</context>

<tasks>

<task type="auto">
  <name>Create Dockerfiles for all 5 Java services</name>
  <files>
    eureka-server/Dockerfile
    api-gateway/Dockerfile
    user-service/Dockerfile
    event-service/Dockerfile
    appointment-service/Dockerfile
  </files>
  <action>
Create identical multi-stage Dockerfiles for all 5 Java services following the Spring Boot layered jar pattern from RESEARCH.md.

Each Dockerfile must have:

1. Builder stage:
   - Base: eclipse-temurin:17-jdk
   - Workdir: /build
   - Copy pom.xml first for dependency caching
   - Run mvn dependency:go-offline -B
   - Copy src directory
   - Run mvn clean package -DskipTests -o
   - Extract layers using: java -Djarmode=tools -jar target/*.jar extract --layers --destination extracted

2. Runtime stage:
   - Base: gcr.io/distroless/java17-debian12
   - Workdir: /application
   - Copy extracted layers in order: dependencies, spring-boot-loader, snapshot-dependencies, application
   - Entrypoint: ["java", "-jar", "application.jar"]

Use the exact pattern from RESEARCH.md "Complete Spring Boot Multi-Stage Dockerfile (with Maven build)". This pattern achieves 50-70% size reduction and ensures build artifacts are excluded from final image.

Do NOT add EXPOSE statements (handled by docker-compose later). Do NOT add ENV variables yet (handled in Phase 3).
  </action>
  <verify>
docker build -t eureka-server:test ./eureka-server
docker build -t api-gateway:test ./api-gateway
docker build -t user-service:test ./user-service
docker build -t event-service:test ./event-service
docker build -t appointment-service:test ./appointment-service

All builds should complete without errors. Check image sizes with:
docker images | grep test
  </verify>
  <done>
All 5 services have Dockerfiles. Running docker build on each service completes successfully. Images are under 300MB each (distroless + application layers). No build errors occur.
  </done>
</task>

<task type="auto">
  <name>Create .dockerignore files for all 5 Java services</name>
  <files>
    eureka-server/.dockerignore
    api-gateway/.dockerignore
    user-service/.dockerignore
    event-service/.dockerignore
    appointment-service/.dockerignore
  </files>
  <action>
Create identical .dockerignore files for all 5 Java services to exclude unnecessary files from the Docker build context.

Use the exact pattern from RESEARCH.md "Java Service .dockerignore" which includes:

Build outputs:
- target/
- build/
- *.jar
- *.war

IDE files:
- .idea/
- .vscode/
- *.iml, *.ipr, *.iws
- .project, .classpath, .settings/

OS files:
- .DS_Store
- Thumbs.db

Git:
- .git/
- .gitignore
- .gitattributes

Secrets and environment:
- .env
- .env.*
- *.pem
- *.key

Documentation:
- README.md
- LICENSE
- *.md

Logs:
- *.log
- logs/

This reduces build context size from 100s MB to under 10MB and prevents secrets from being copied into images.
  </action>
  <verify>
# Verify .dockerignore exists for each service
ls -la eureka-server/.dockerignore api-gateway/.dockerignore user-service/.dockerignore event-service/.dockerignore appointment-service/.dockerignore

# Test that build context respects .dockerignore (target/ should not be sent)
docker build --no-cache -t test-ignore ./user-service 2>&1 | grep -i "sending build context"
  </verify>
  <done>
All 5 services have .dockerignore files. Build context size is significantly reduced (under 10MB). Sensitive files (.env, .pem, .key) and build artifacts (target/) are excluded.
  </done>
</task>

</tasks>

<verification>
After completing both tasks:

1. Build all images:
```bash
docker build -t dakik/eureka-server:latest ./eureka-server
docker build -t dakik/api-gateway:latest ./api-gateway
docker build -t dakik/user-service:latest ./user-service
docker build -t dakik/event-service:latest ./event-service
docker build -t dakik/appointment-service:latest ./appointment-service
```

2. Verify image sizes (should be under 300MB each):
```bash
docker images | grep dakik
```

3. Verify layers are properly separated:
```bash
docker history dakik/user-service:latest
# Should show separate layers for dependencies, spring-boot-loader, snapshot-dependencies, application
```

4. Verify .dockerignore working (target/ excluded):
```bash
# Build context size should be <10MB
docker build --no-cache ./user-service 2>&1 | grep "Sending build context"
```
</verification>

<success_criteria>
1. All 5 Java services have Dockerfile and .dockerignore
2. docker build succeeds for all 5 services
3. Final images are optimized (under 300MB each)
4. Multi-stage builds are used (builder + runtime stages visible in docker history)
5. Build artifacts (target/, *.jar) are excluded from final images
6. Sensitive files (.env, .pem, .key) are excluded via .dockerignore
7. Base images are eclipse-temurin:17-jdk (build) and gcr.io/distroless/java17-debian12 (runtime)
</success_criteria>

<output>
After completion, create `.planning/phases/01-container-images/01-01-SUMMARY.md` with:
- Files created (10 files total: 5 Dockerfiles + 5 .dockerignore)
- Image sizes for each service
- Build times
- Any issues encountered and resolutions
</output>
